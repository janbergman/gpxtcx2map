<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Orienteering Map - Full View</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
            font-family: sans-serif;
            background-color: #f5f5f5;
            color: #222;
        }

        body {
            position: relative;
        }

        #mapCanvas {
            width: 100vw;
            height: 100vh;
            display: block;
            background-color: #e0e0e0;
            cursor: default;
        }

        #fileOverlay {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.65);
            z-index: 100;
        }

        #fileOverlay.hidden {
            display: none;
        }

        .overlay-content {
            background-color: #ffffff;
            padding: 24px 28px;
            border-radius: 12px;
            box-shadow: 0 12px 36px rgba(0, 0, 0, 0.25);
            width: min(420px, 90vw);
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .overlay-content h2 {
            margin: 0;
            font-size: 1.4rem;
            color: #1d1d1d;
        }

        .overlay-content p {
            margin: 0;
            font-size: 0.95rem;
            color: #555;
        }

        .overlay-content label {
            font-weight: 600;
            font-size: 0.9rem;
            color: #333;
            margin-top: 8px;
        }

        .overlay-content input[type="file"] {
            margin-top: 4px;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 6px;
            cursor: pointer;
        }

        #status {
            font-size: 0.95rem;
            font-weight: 600;
            color: #1a4d8f;
        }

        .overlay-content .checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 500;
            font-size: 0.9rem;
            color: #333;
            cursor: pointer;
        }

        .overlay-content .checkbox-label input[type="checkbox"] {
            width: 16px;
            height: 16px;
        }

    </style>
</head>
<body>
    <!-- Removed H1 -->
    <div id="fileOverlay">
        <div class="overlay-content">
            <h2>Load Map &amp; Track</h2>
            <p>Select a map image and the TCX or GPX track you want to review. The viewer switches to full screen once both files are loaded.</p>

            <label for="mapFile">Map Image</label>
            <input type="file" id="mapFile" accept="image/*">

            <label for="trackFile">Track File (TCX or GPX)</label>
            <input type="file" id="trackFile" accept=".tcx,.gpx,application/vnd.garmin.tcx+xml,application/gpx+xml">

            <label class="checkbox-label">
                <input type="checkbox" id="wideTrackToggle">
                Wide track (6x)
            </label>

            <label class="checkbox-label">
                <input type="checkbox" id="kmMarksToggle">
                Show km marks
            </label>

            <div id="status" aria-live="polite" style="display:none;"></div>
        </div>
    </div>

    <canvas id="mapCanvas"></canvas>

    <script>
        // --- DOM Elements ---
        const mapFileInput = document.getElementById('mapFile');
        const trackFileInput = document.getElementById('trackFile');
        const canvas = document.getElementById('mapCanvas');
        const ctx = canvas.getContext('2d');
        const statusEl = document.getElementById('status');
        const overlayEl = document.getElementById('fileOverlay');
        const wideTrackToggle = document.getElementById('wideTrackToggle');
        const kmMarksToggle = document.getElementById('kmMarksToggle');
        const globalAnchorListEl = null;


        // --- State Variables (mostly same) ---
        let mapImage = null;
        let originalMapFileName = 'map_with_track.png'; // Default filename if original is not available
        let originalTrackPoints = [];
        let modelTrackPoints = [];
        let controls = [];
        let displayTrackScreenPoints = [];

        let geoTrackStats = {};
        let initialDisplayTransform = { scale: 1, rotation: 0, tx: 0, ty: 0 };
        let activeGlobalTransform = null;

        let viewTransform = { scale: 1.0, offsetX: 0, offsetY: 0 };
        const MIN_ZOOM = 0.05; const MAX_ZOOM = 20.0;

        let currentMode = 'idle';
        let globalAnchorPairs = [];
        let selectedControlForPlacementId = null;

        let activeDragControlId = null;
        let isPanning = false;
        let lastPanX = 0, lastPanY = 0;
        let didDrag = false; // To distinguish a click from a drag-release

        let appearance = { trackColor: '#FF00FF', trackWidth: 2, controlColor: '#FF0000', controlColorGlobal: '#00AAFF', controlColorInitial: '#00FFFF', controlRadius: 16, controlColorCustom: '#0000FF' };
        let customControlIdCounter = 0;
        let showWideTrack = false;
        let showKmMarks = false;
        let kmMarkers = [];
        let totalTrackLengthKm = 0;

        // --- Initialization ---
        function init() {
            mapFileInput.addEventListener('change', loadMapImage);
            trackFileInput.addEventListener('change', loadTrackFile);

            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseleave', handleMouseUp);
            canvas.addEventListener('wheel', handleMouseWheel, { passive: false });

            window.addEventListener('resize', handleWindowResize);
            window.addEventListener('keydown', handleKeyDown);

            if (wideTrackToggle) {
                wideTrackToggle.addEventListener('change', () => {
                    showWideTrack = wideTrackToggle.checked;
                    redrawCanvas();
                });
                showWideTrack = wideTrackToggle.checked;
            }
            if (kmMarksToggle) {
                kmMarksToggle.addEventListener('change', () => {
                    showKmMarks = kmMarksToggle.checked;
                    redrawCanvas();
                });
                showKmMarks = kmMarksToggle.checked;
            }

            updateStatus('Load map and TCX file.');
            resizeCanvasToViewport();
            redrawCanvas();
        }

        function resizeCanvasToViewport() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        function updateStatus(message) {
            try {
                const plainMessage = message.replace(/<[^>]+>/g, '');
                console.log(`[status] ${plainMessage}`);
            } catch {
                console.log(`[status] ${message}`);
            }
        }

        function updateButtonStates() {
            // UI buttons have been removed; no state to manage.
        }

        function handleWindowResize() {
            resizeCanvasToViewport();
            if (mapImage) {
                zoomToFitMap();
            } else {
                redrawCanvas();
            }
        }

        function maybeBeginSession() {
            if (!(mapImage && originalTrackPoints.length > 0)) return;
            if (overlayEl && !overlayEl.classList.contains('hidden')) {
                overlayEl.classList.add('hidden');
                if (statusEl) {
                    statusEl.classList.remove('floating-status');
                }
            }
            resizeCanvasToViewport();
            redrawCanvas();
        }

        function mapToScreen(mapX, mapY) {
            return {
                x: (mapX - viewTransform.offsetX) * viewTransform.scale,
                y: (mapY - viewTransform.offsetY) * viewTransform.scale
            };
        }

        function screenToMap(screenX, screenY) {
            return {
                x: (screenX / viewTransform.scale) + viewTransform.offsetX,
                y: (screenY / viewTransform.scale) + viewTransform.offsetY
            };
        }

        function transformModelToMapPixels(modelX, modelY, trackGeoTransform) {
            const s = trackGeoTransform.scale;
            const R = trackGeoTransform.rotation;
            const cosR = Math.cos(R);
            const sinR = Math.sin(R);
            const mapX = s * (modelX * cosR - modelY * sinR) + trackGeoTransform.tx;
            const mapY = s * (-modelX * sinR - modelY * cosR) + trackGeoTransform.ty;
            return { x: mapX, y: mapY };
        }

        function loadMapImage(event) {
            const file = event.target.files[0]; if (!file) return;

            // Reset all track and alignment data for a clean slate
            originalTrackPoints = [];
            modelTrackPoints = [];
            controls = [];
            displayTrackScreenPoints = [];
            activeGlobalTransform = null;
            globalAnchorPairs = [];
            kmMarkers = [];
            totalTrackLengthKm = 0;
            currentMode = 'idle';
            updateGlobalAnchorListUI();
            
            originalMapFileName = file.name; // Store original filename
            const reader = new FileReader();
            reader.onload = (e) => {
                mapImage = new Image();
                mapImage.onload = () => {
                    resizeCanvasToViewport();
                    zoomToFitMap();
                    updateStatus('Map loaded. Load TCX file.');
                    updateButtonStates();
                    maybeBeginSession();
                };
                mapImage.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function zoomToFitMap() {
            if (!mapImage || !canvas.width || !canvas.height ) return;
            const mw = mapImage.width; const mh = mapImage.height;
            const cw = canvas.width; const ch = canvas.height;
            if (mw === 0 || mh === 0) return;
            const scaleX = cw / mw; const scaleY = ch / mh;
            viewTransform.scale = Math.min(scaleX, scaleY);
            viewTransform.scale = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, viewTransform.scale));
            viewTransform.offsetX = (mw - cw / viewTransform.scale) / 2;
            viewTransform.offsetY = (mh - ch / viewTransform.scale) / 2;
            redrawCanvas();
        }

        function loadTrackFile(event) {
            const file = event.target.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    // Clear all old track and alignment data first
                    originalTrackPoints = []; 
                    controls = []; 
                    activeGlobalTransform = null; 
                    globalAnchorPairs = [];
                    kmMarkers = [];
                    totalTrackLengthKm = 0;
                    updateGlobalAnchorListUI();

                    const xmlDoc = new DOMParser().parseFromString(e.target.result, "application/xml");
                    if (xmlDoc.getElementsByTagName("parsererror").length > 0) throw new Error("Invalid XML");

                    const fileNameLower = file.name.toLowerCase();
                    const rootName = xmlDoc.documentElement ? xmlDoc.documentElement.nodeName.toLowerCase() : '';
                    let trackType = 'tcx';
                    if (fileNameLower.endsWith('.gpx') || rootName.includes('gpx') || xmlDoc.getElementsByTagName('trkpt').length > 0) {
                        trackType = 'gpx';
                    }

                    const { trackPoints, controlCandidates } = trackType === 'gpx'
                        ? extractTrackDataFromGpx(xmlDoc)
                        : extractTrackDataFromTcx(xmlDoc);

                    if (!trackPoints.length) throw new Error("No trackpoints found.");
                    console.log(`[track] Loaded ${trackPoints.length} points (${trackType.toUpperCase()}) with ${controlCandidates.length} control candidates.`);

                    geoTrackStats = computeGeoTrackStats(trackPoints);
                    originalTrackPoints = trackPoints.map((pt, index) => ({
                        lat: pt.lat,
                        lon: pt.lon,
                        originalIndex: index
                    }));
                    annotateOriginalTrackPointsWithDistance();

                    if (originalTrackPoints.length > 0) {
                        controls.push(createControl('control-track-start',
                            originalTrackPoints[0].lat,
                            originalTrackPoints[0].lon,
                            originalTrackPoints[0].originalIndex));
                        if (originalTrackPoints.length > 1) {
                            const last = originalTrackPoints[originalTrackPoints.length - 1];
                            controls.push(createControl('control-track-end', last.lat, last.lon, last.originalIndex));
                        }
                    }

                    const nearestIndex = (lat, lon) => findNearestTrackPointIndex(lat, lon, trackPoints);
                    let controlIdCounter = 0;
                    controlCandidates.forEach(candidate => {
                        const idx = nearestIndex(candidate.lat, candidate.lon);
                        if (idx !== -1) {
                            controls.push(createControl(`control-lap-${controlIdCounter++}`, candidate.lat, candidate.lon, idx));
                        }
                    });

                    const uniqueControls = [];
                    const seenIndexes = new Set();
                    controls.forEach(c => {
                        if (!seenIndexes.has(c.originalTrackPointIndex)) {
                            uniqueControls.push(c);
                            seenIndexes.add(c.originalTrackPointIndex);
                        }
                    });
                    controls = uniqueControls.sort((a, b) => a.originalTrackPointIndex - b.originalTrackPointIndex);

                    if (mapImage) {
                        processLoadedDataAndSetInitialDisplay();
                    } else {
                        updateStatus(`${trackType.toUpperCase()} track loaded. Load map.`);
                    }
                    updateButtonStates();
                } catch (err) { updateStatus(`Error parsing track: ${err.message}`); console.error(err); }
            };
            reader.readAsText(file);
        }
        function extractTrackDataFromTcx(xmlDoc) {
            const trackPoints = [];
            const controlCandidates = [];
            Array.from(xmlDoc.getElementsByTagName('Trackpoint')).forEach(tpNode => {
                const posNode = tpNode.getElementsByTagName('Position')[0];
                if (!posNode) return;
                const lat = parseFloat(posNode.getElementsByTagName('LatitudeDegrees')[0]?.textContent);
                const lon = parseFloat(posNode.getElementsByTagName('LongitudeDegrees')[0]?.textContent);
                if (!isNaN(lat) && !isNaN(lon)) {
                    trackPoints.push({ lat, lon });
                }
            });
            Array.from(xmlDoc.getElementsByTagName('Lap')).forEach(lapNode => {
                const firstLapTpNode = lapNode.getElementsByTagName('Trackpoint')[0];
                if (!firstLapTpNode) return;
                const posNode = firstLapTpNode.getElementsByTagName('Position')[0];
                if (!posNode) return;
                const lat = parseFloat(posNode.getElementsByTagName('LatitudeDegrees')[0]?.textContent);
                const lon = parseFloat(posNode.getElementsByTagName('LongitudeDegrees')[0]?.textContent);
                if (!isNaN(lat) && !isNaN(lon)) {
                    controlCandidates.push({ lat, lon });
                }
            });
            return { trackPoints, controlCandidates };
        }
        function extractTrackDataFromGpx(xmlDoc) {
            const trackPoints = [];
            Array.from(xmlDoc.getElementsByTagName('trkpt')).forEach(trkpt => {
                const lat = parseFloat(trkpt.getAttribute('lat'));
                const lon = parseFloat(trkpt.getAttribute('lon'));
                if (!isNaN(lat) && !isNaN(lon)) {
                    trackPoints.push({ lat, lon });
                }
            });
            if (!trackPoints.length) {
                Array.from(xmlDoc.getElementsByTagName('rtept')).forEach(rtept => {
                    const lat = parseFloat(rtept.getAttribute('lat'));
                    const lon = parseFloat(rtept.getAttribute('lon'));
                    if (!isNaN(lat) && !isNaN(lon)) {
                        trackPoints.push({ lat, lon });
                    }
                });
            }
            return { trackPoints, controlCandidates: [] };
        }
        function computeGeoTrackStats(trackPoints) {
            let minLat = Infinity, maxLat = -Infinity, minLon = Infinity, maxLon = -Infinity;
            trackPoints.forEach(pt => {
                minLat = Math.min(minLat, pt.lat);
                maxLat = Math.max(maxLat, pt.lat);
                minLon = Math.min(minLon, pt.lon);
                maxLon = Math.max(maxLon, pt.lon);
            });
            const centerLat = minLat + (maxLat - minLat) / 2;
            const centerLon = minLon + (maxLon - minLon) / 2;
            const heightDeg = maxLat - minLat;
            const lonCorrectionFactor = Math.cos(centerLat * Math.PI / 180);
            const widthDegCorrected = (maxLon - minLon) * lonCorrectionFactor;
            return {
                minLat, maxLat, minLon, maxLon,
                centerLat, centerLon,
                heightDeg,
                lonCorrectionFactor,
                widthDegCorrected
            };
        }
        function haversineDistanceMeters(lat1, lon1, lat2, lon2) {
            const toRad = Math.PI / 180;
            const dLat = (lat2 - lat1) * toRad;
            const dLon = (lon2 - lon1) * toRad;
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                      Math.cos(lat1 * toRad) * Math.cos(lat2 * toRad) *
                      Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            const earthRadiusMeters = 6371000;
            return earthRadiusMeters * c;
        }
        function annotateOriginalTrackPointsWithDistance() {
            kmMarkers = [];
            totalTrackLengthKm = 0;
            if (!originalTrackPoints.length) return;
            originalTrackPoints[0].cumDistKm = 0;
            let cumulativeMeters = 0;
            for (let i = 1; i < originalTrackPoints.length; i++) {
                const prev = originalTrackPoints[i - 1];
                const curr = originalTrackPoints[i];
                const segmentMeters = haversineDistanceMeters(prev.lat, prev.lon, curr.lat, curr.lon);
                cumulativeMeters += isFinite(segmentMeters) ? segmentMeters : 0;
                curr.cumDistKm = cumulativeMeters / 1000;
            }
            totalTrackLengthKm = cumulativeMeters / 1000;
        }
        function findNearestTrackPointIndex(lat, lon, trackPoints) {
            let nearestIndex = -1;
            let nearestDistSq = Infinity;
            trackPoints.forEach((pt, index) => {
                const dLat = pt.lat - lat;
                const dLon = pt.lon - lon;
                const distSq = dLat * dLat + dLon * dLon;
                if (distSq < nearestDistSq) {
                    nearestDistSq = distSq;
                    nearestIndex = index;
                }
            });
            return nearestIndex;
        }
        function createControl(id, lat, lon, originalTrackPointIndex) {
            return {
                id,
                originalLat: lat,
                originalLon: lon,
                modelX: 0,
                modelY: 0,
                mapX: 0,
                mapY: 0,
                isUserManuallyPositioned: false,
                isGlobalAnchor: false,
                originalTrackPointIndex
            };
        }

        function processLoadedDataAndSetInitialDisplay() {
            modelTrackPoints = originalTrackPoints.map(p => ({
                correctedX: (p.lon - geoTrackStats.centerLon) * geoTrackStats.lonCorrectionFactor,
                correctedY: p.lat - geoTrackStats.centerLat,
                originalIndex: p.originalIndex
            }));
            controls.forEach(c => {
                c.modelX = (c.originalLon - geoTrackStats.centerLon) * geoTrackStats.lonCorrectionFactor;
                c.modelY = (c.originalLat - geoTrackStats.centerLat);
            });
            if (!mapImage) { updateStatus("Map image not loaded, cannot process further."); return; }
            const trackModelWidth = geoTrackStats.widthDegCorrected || 0.0001;
            const trackModelHeight = geoTrackStats.heightDeg || 0.0001;
            let scaleFactorMap = Math.min( (mapImage.width * 0.8) / trackModelWidth, (mapImage.height * 0.8) / trackModelHeight );
            if (!isFinite(scaleFactorMap) || scaleFactorMap <= 0) scaleFactorMap = Math.min(mapImage.width, mapImage.height) / 0.01 ;
            initialDisplayTransform = {
                scale: scaleFactorMap, rotation: 0,
                tx: mapImage.width / 2, ty: mapImage.height / 2
            };
            controls.forEach(c => {
                const mapPixelPos = transformModelToMapPixels(c.modelX, c.modelY, initialDisplayTransform);
                c.mapX = mapPixelPos.x; c.mapY = mapPixelPos.y;
                c.isUserManuallyPositioned = false; c.isGlobalAnchor = false;
            });
            currentMode = 'idle'; activeGlobalTransform = null; globalAnchorPairs = [];
            updateGlobalAnchorListUI();
            regenerateWarpedTrack();
            updateStatus("Map and TCX loaded. Drag controls to fine-tune the track; use the mouse wheel to zoom.");
            maybeBeginSession();
        }

        function handleMouseDown(event) {
            const rect = canvas.getBoundingClientRect();
            const screenX = event.clientX - rect.left;
            const screenY = event.clientY - rect.top;

            if (currentMode.startsWith('selectingControlForGlobal') || currentMode.startsWith('placingOnMapForGlobal')) {
            } else {
                activeDragControlId = null;
                if (mapImage) {
                    for (let i = controls.length - 1; i >= 0; i--) {
                        const c = controls[i];
                        const controlScreenPos = mapToScreen(c.mapX, c.mapY);
                        const distSq = (screenX - controlScreenPos.x)**2 + (screenY - controlScreenPos.y)**2;
                        if (distSq < (appearance.controlRadius + 3)**2) {
                            activeDragControlId = c.id;
                            dragOffsetX = screenX - controlScreenPos.x;
                            dragOffsetY = screenY - controlScreenPos.y;
                            canvas.style.cursor = 'grabbing';
                            if (currentMode === 'idle') currentMode = 'fineTuning';
                            c.isUserManuallyPositioned = true; 
                            c.isGlobalAnchor = false;
                            didDrag = false; // Reset drag flag
                            redrawCanvas(); return;
                        }
                    }
                }
            }
            if (!activeDragControlId && !(currentMode.startsWith('placingOnMapForGlobal'))) {
                 if (mapImage) {
                    isPanning = true; lastPanX = screenX; lastPanY = screenY;
                    canvas.style.cursor = 'grabbing';
                 }
            }
        }

        function handleMouseMove(event) {
            const rect = canvas.getBoundingClientRect();
            const screenX = event.clientX - rect.left;
            const screenY = event.clientY - rect.top;
            if (activeDragControlId) {
                didDrag = true; // It's a drag, not a click
                const control = controls.find(c => c.id === activeDragControlId);
                if (control) {
                    const targetScreenX = screenX - dragOffsetX;
                    const targetScreenY = screenY - dragOffsetY;
                    const targetMapPos = screenToMap(targetScreenX, targetScreenY);
                    control.mapX = targetMapPos.x; control.mapY = targetMapPos.y;
                    regenerateWarpedTrack(); redrawCanvas();
                }
            } else if (isPanning) {
                const dx = screenX - lastPanX; const dy = screenY - lastPanY;
                viewTransform.offsetX -= dx / viewTransform.scale;
                viewTransform.offsetY -= dy / viewTransform.scale;
                lastPanX = screenX; lastPanY = screenY;
                redrawCanvas();
            } else {
                let hoveringControl = false;
                if (mapImage && (currentMode === 'selectingControlForGlobal1' || currentMode === 'selectingControlForGlobal2' || currentMode === 'fineTuning' || currentMode === 'idle')) {
                     for (let c of controls) {
                        const controlScreenPos = mapToScreen(c.mapX, c.mapY);
                        const distSq = (screenX - controlScreenPos.x)**2 + (screenY - controlScreenPos.y)**2;
                        if (distSq < (appearance.controlRadius + 3)**2) { hoveringControl = true; break; }
                    }
                }
                if (hoveringControl) canvas.style.cursor = 'pointer';
                else if (currentMode.startsWith('placingOnMapForGlobal')) canvas.style.cursor = 'crosshair';
                else if (mapImage && !isPanning) canvas.style.cursor = 'grab';
                else canvas.style.cursor = 'default';
            }
        }

        function handleMouseUp() {
            if (activeDragControlId) { activeDragControlId = null; redrawCanvas(); }
            if (isPanning) { isPanning = false; }
            const rect = canvas.getBoundingClientRect();
            const event = new MouseEvent('mousemove', { clientX: lastPanX + rect.left, clientY: lastPanY + rect.top });
            canvas.dispatchEvent(event);
        }

        function handleMouseWheel(event) {
            if (!mapImage) return;
            event.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mouseScreenX = event.clientX - rect.left;
            const mouseScreenY = event.clientY - rect.top;
            const mouseMapPosBeforeZoom = screenToMap(mouseScreenX, mouseScreenY);
            const zoomFactor = 1.1;
            const oldScale = viewTransform.scale;
            if (event.deltaY < 0) { viewTransform.scale *= zoomFactor; }
            else { viewTransform.scale /= zoomFactor; }
            viewTransform.scale = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, viewTransform.scale));
            if (Math.abs(viewTransform.scale - oldScale) < 1e-7) return;
            viewTransform.offsetX = mouseMapPosBeforeZoom.x - (mouseScreenX / viewTransform.scale);
            viewTransform.offsetY = mouseMapPosBeforeZoom.y - (mouseScreenY / viewTransform.scale);
            redrawCanvas();
        }

        function handleKeyDown(event) {
            if (!event || typeof event.code !== 'string') return;
            const keyLower = (event.key || '').toLowerCase();
            if (!event.altKey && !event.metaKey && !event.shiftKey && !event.ctrlKey && keyLower === 'd') {
                event.preventDefault();
                saveImage();
            }
        }

        // --- HELPER: Find closest point on a polyline ---
        function getClosestPointOnPolyline(point, polyline) {
            let closest = { distance: Infinity, point: null, segmentIndex: -1, progress: 0 };
            if (polyline.length < 2) return closest;

            for (let i = 0; i < polyline.length - 1; i++) {
                const p1 = polyline[i];
                const p2 = polyline[i+1];
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;

                if (dx === 0 && dy === 0) continue; // Skip zero-length segments

                const t = ((point.x - p1.x) * dx + (point.y - p1.y) * dy) / (dx * dx + dy * dy);
                const tClamped = Math.max(0, Math.min(1, t));

                const closestPointOnSegment = { x: p1.x + tClamped * dx, y: p1.y + tClamped * dy };
                const distSq = (point.x - closestPointOnSegment.x)**2 + (point.y - closestPointOnSegment.y)**2;

                if (distSq < closest.distance) {
                    closest = {
                        distance: distSq,
                        point: closestPointOnSegment,
                        segmentIndex: i,
                        progress: tClamped
                    };
                }
            }
            closest.distance = Math.sqrt(closest.distance);
            return closest;
        }

        // --- HELPER: Find model details for a point on the warped map track ---
        function findModelDetailsForMapPoint(mapPoint, segmentIndex, progress) {
            if (segmentIndex >= displayTrackScreenPoints.length - 1) return null;
            const p1 = displayTrackScreenPoints[segmentIndex];
            const p2 = displayTrackScreenPoints[segmentIndex + 1];
            if (p1 == null || p2 == null) return null;
            const modelIndex = p1.modelIndex + (p2.modelIndex - p1.modelIndex) * progress;
            const modelX = p1.modelX + (p2.modelX - p1.modelX) * progress;
            const modelY = p1.modelY + (p2.modelY - p1.modelY) * progress;
            return { modelX, modelY, originalTrackPointIndex: modelIndex };
        }


        function handleCanvasClickForPlacement(event) {
            if (didDrag) {
                didDrag = false;
                return;
            }
            if (isPanning || activeDragControlId || !mapImage) return;
            const rect = canvas.getBoundingClientRect();
            const screenX = event.clientX - rect.left;
            const screenY = event.clientY - rect.top;
            const mapClickPos = screenToMap(screenX, screenY);

            // Check if a control was clicked
            let clickedCtrl = null;
            for (let c of controls) {
                const controlScreenPos = mapToScreen(c.mapX, c.mapY);
                const distSq = (screenX - controlScreenPos.x)**2 + (screenY - controlScreenPos.y)**2;
                if (distSq < (appearance.controlRadius + 3)**2) {
                    clickedCtrl = c;
                    break;
                }
            }

            if (clickedCtrl) {
                // A control was clicked
                if (clickedCtrl.isCustom) {
                    // Delete custom control
                    controls = controls.filter(c => c.id !== clickedCtrl.id);
                    regenerateWarpedTrack();
                    redrawCanvas();
                    updateStatus(`Custom control removed.`);
                    return;
                }

                if (currentMode === 'selectingControlForGlobal1' || currentMode === 'selectingControlForGlobal2') {
                    if (globalAnchorPairs.length === 1 && globalAnchorPairs[0].controlId === clickedCtrl.id) { 
                        updateStatus("<b>Error:</b> Cannot select the same control point twice."); 
                        return; 
                    }
                    selectedControlForPlacementId = clickedCtrl.id;
                    clickedCtrl.isGlobalAnchor = true;
                    if (currentMode === 'selectingControlForGlobal1') { 
                        currentMode = 'placingOnMapForGlobal1'; 
                        updateStatus(`<b>Step 2/4:</b> Ctrl ${clickedCtrl.id.split('-').pop()} selected. Click its location on map.`); 
                    } else { 
                        currentMode = 'placingOnMapForGlobal2'; 
                        updateStatus(`<b>Step 4/4:</b> Ctrl ${clickedCtrl.id.split('-').pop()} selected. Click its location on map.`); 
                    }
                    redrawCanvas();
                } else if (clickedCtrl.isUserManuallyPositioned && (currentMode === 'fineTuning' || currentMode === 'idle')) {
                    // Un-align the control if it was already manually positioned
                    clickedCtrl.isUserManuallyPositioned = false;
                    clickedCtrl.isGlobalAnchor = false;
                    regenerateWarpedTrack();
                    redrawCanvas();
                    updateStatus(`Control ${clickedCtrl.id.split('-').pop()} alignment reset.`);
                }
            } else {
                // The click was on the map, not a control
                if (currentMode === 'placingOnMapForGlobal1' || currentMode === 'placingOnMapForGlobal2') {
                    const controlToPlace = controls.find(c => c.id === selectedControlForPlacementId);
                    if (!controlToPlace) return;
                    controlToPlace.mapX = mapClickPos.x; controlToPlace.mapY = mapClickPos.y;
                    controlToPlace.isUserManuallyPositioned = true; controlToPlace.isGlobalAnchor = true;
                    globalAnchorPairs.push({ controlId: controlToPlace.id, mapX: mapClickPos.x, mapY: mapClickPos.y, modelX: controlToPlace.modelX, modelY: controlToPlace.modelY });
                    updateGlobalAnchorListUI();

                    if (currentMode === 'placingOnMapForGlobal1') { 
                        currentMode = 'selectingControlForGlobal2'; 
                        updateStatus(`<b>Step 3/4:</b> First pair set. Click 2nd control on track.`); 
                    } else {
                        const p1 = globalAnchorPairs[0]; const p2 = globalAnchorPairs[1];
                        const S1_model = { x: p1.modelX, y: p1.modelY }; const D1_map = { x: p1.mapX, y: p1.mapY };
                        const S2_model = { x: p2.modelX, y: p2.modelY }; const D2_map = { x: p2.mapX, y: p2.mapY };
                        const dSmx = S2_model.x - S1_model.x; const dSmy = S2_model.y - S1_model.y;
                        const dDx_map = D2_map.x - D1_map.x; const dDy_map = D2_map.y - D1_map.y;
                        const den = dSmx * dSmx + dSmy * dSmy;
                        if (Math.abs(den) < 1e-9) { updateStatus("<b>Error:</b> Model points for global alignment are identical. Reset and choose different points."); resetAlignment(); return; }
                        const sCosR = (dDx_map * dSmx - dDy_map * dSmy) / den;
                        const sSinR = (-dDx_map * dSmy - dDy_map * dSmx) / den;
                        const s_val = Math.sqrt(sCosR*sCosR + sSinR*sSinR);
                        const R_val = Math.atan2(sSinR, sCosR);
                        activeGlobalTransform = {
                            scale: s_val, rotation: R_val,
                            tx: D1_map.x - (sCosR * S1_model.x - sSinR * S1_model.y),
                            ty: D1_map.y - (-sSinR * S1_model.x - sCosR * S1_model.y)
                        };
                        controls.forEach(c => {
                            if (!c.isGlobalAnchor) {
                                const mapPixelPos = transformModelToMapPixels(c.modelX, c.modelY, activeGlobalTransform);
                                c.mapX = mapPixelPos.x; c.mapY = mapPixelPos.y;
                                c.isUserManuallyPositioned = false;
                            }
                        });
                        currentMode = 'fineTuning'; updateStatus("<b>Global Alignment Set!</b> Fine-tune by dragging controls.");
                    }
                    selectedControlForPlacementId = null;
                    regenerateWarpedTrack(); 
                    redrawCanvas();
                } else if ((currentMode === 'fineTuning' || currentMode === 'idle') && displayTrackScreenPoints.length > 1) {
                    // CREATE NEW CUSTOM CONTROL
                    const closest = getClosestPointOnPolyline(mapClickPos, displayTrackScreenPoints);
                    const clickTolerance = 10 / viewTransform.scale; // 10 screen pixels tolerance

                    if (closest.distance < clickTolerance) {
                        const modelDetails = findModelDetailsForMapPoint(closest.point, closest.segmentIndex, closest.progress);
                        if (modelDetails) {
                            const newControl = {
                                id: `control-custom-${customControlIdCounter++}`,
                                modelX: modelDetails.modelX,
                                modelY: modelDetails.modelY,
                                mapX: closest.point.x,
                                mapY: closest.point.y,
                                isUserManuallyPositioned: true, // It's manually placed by definition
                                isGlobalAnchor: false,
                                isCustom: true, // Flag for custom points
                                originalTrackPointIndex: modelDetails.originalTrackPointIndex
                            };
                            controls.push(newControl);
                            controls.sort((a,b) => a.originalTrackPointIndex - b.originalTrackPointIndex);
                            regenerateWarpedTrack();
                            redrawCanvas();
                            updateStatus(`New custom control added.`);
                        }
                    }
                }
            }
            updateButtonStates();
        }
        canvas.addEventListener('click', handleCanvasClickForPlacement);

        function regenerateWarpedTrack() {
            if (modelTrackPoints.length === 0) { displayTrackScreenPoints = []; updateButtonStates(); return; }

            const currentBaseTransform = activeGlobalTransform || initialDisplayTransform;

            // 1. Update positions of all non-manual controls based on manual anchors.
            const manualAnchors = controls.filter(c => c.isUserManuallyPositioned)
                                          .sort((a, b) => a.originalTrackPointIndex - b.originalTrackPointIndex);

            controls.forEach(c => {
                if (c.isUserManuallyPositioned) return;

                let newMapPos;
                if (manualAnchors.length === 0) {
                    newMapPos = transformModelToMapPixels(c.modelX, c.modelY, currentBaseTransform);
                } else if (manualAnchors.length === 1) {
                    const manual = manualAnchors[0];
                    const modelOffset = { x: c.modelX - manual.modelX, y: c.modelY - manual.modelY };
                    const s = currentBaseTransform.scale;
                    const R = currentBaseTransform.rotation;
                    const cosR = Math.cos(R), sinR = Math.sin(R);
                    const mapOffsetX = s * (modelOffset.x * cosR - modelOffset.y * sinR);
                    const mapOffsetY = s * (-modelOffset.x * sinR - modelOffset.y * cosR);
                    newMapPos = { x: manual.mapX + mapOffsetX, y: manual.mapY + mapOffsetY };
                } else {
                    let prevAnchor = null, nextAnchor = null;
                    for (let i = 0; i < manualAnchors.length; i++) {
                        if (manualAnchors[i].originalTrackPointIndex > c.originalTrackPointIndex) {
                            nextAnchor = manualAnchors[i];
                            break;
                        }
                        prevAnchor = manualAnchors[i];
                    }

                    let S1_anchor = prevAnchor, S2_anchor = nextAnchor;
                    if (!S1_anchor) { S1_anchor = manualAnchors[0]; S2_anchor = manualAnchors[1]; }
                    else if (!S2_anchor) { S2_anchor = manualAnchors[manualAnchors.length - 1]; S1_anchor = manualAnchors[manualAnchors.length - 2]; }

                    const S1 = { x: S1_anchor.modelX, y: S1_anchor.modelY }, D1 = { x: S1_anchor.mapX, y: S1_anchor.mapY };
                    const S2 = { x: S2_anchor.modelX, y: S2_anchor.modelY }, D2 = { x: S2_anchor.mapX, y: S2_anchor.mapY };
                    const dSmx = S2.x - S1.x, dSmy = S2.y - S1.y, dDx = D2.x - D1.x, dDy = D2.y - D1.y;
                    const den = dSmx * dSmx + dSmy * dSmy;

                    if (Math.abs(den) < 1e-9) {
                        const totalIndexSpan = S2_anchor.originalTrackPointIndex - S1_anchor.originalTrackPointIndex;
                        const progress = totalIndexSpan > 0 ? (c.originalTrackPointIndex - S1_anchor.originalTrackPointIndex) / totalIndexSpan : 0;
                        newMapPos = { x: D1.x + progress * dDx, y: D1.y + progress * dDy };
                    } else {
                        const sCosR_seg = (dDx * dSmx - dDy * dSmy) / den;
                        const sSinR_seg = (-dDx * dSmy - dDy * dSmx) / den;
                        const Tx_seg = D1.x - (sCosR_seg * S1.x - sSinR_seg * S1.y);
                        const Ty_seg = D1.y - (-sSinR_seg * S1.x - sCosR_seg * S1.y);
                        newMapPos = {
                            x: sCosR_seg * c.modelX - sSinR_seg * c.modelY + Tx_seg,
                            y: -sSinR_seg * c.modelX - sCosR_seg * c.modelY + Ty_seg
                        };
                    }
                }
                c.mapX = newMapPos.x;
                c.mapY = newMapPos.y;
            });

            // 2. Now, build the anchor list for drawing the track line, using the updated control positions.
            const anchors = [];
            controls.forEach(c => {
                anchors.push({ modelX: c.modelX, modelY: c.modelY, mapX: c.mapX, mapY: c.mapY,
                    originalTrackPointIndex: c.originalTrackPointIndex, id: c.id });
            });

            // Add implicit start/end points if not controlled
            const trackStartIndex = modelTrackPoints[0]?.originalIndex;
            if (trackStartIndex !== undefined && !anchors.find(a => a.originalTrackPointIndex === trackStartIndex)) {
                const c = { modelX: modelTrackPoints[0].correctedX, modelY: modelTrackPoints[0].correctedY, originalTrackPointIndex: trackStartIndex };
                // Find its position just like we did for non-manual controls
                 let newMapPos;
                if (manualAnchors.length === 0) {
                    newMapPos = transformModelToMapPixels(c.modelX, c.modelY, currentBaseTransform);
                } else if (manualAnchors.length === 1) {
                    const manual = manualAnchors[0];
                    const modelOffset = { x: c.modelX - manual.modelX, y: c.modelY - manual.modelY };
                    const s = currentBaseTransform.scale;
                    const R = currentBaseTransform.rotation;
                    const cosR = Math.cos(R), sinR = Math.sin(R);
                    const mapOffsetX = s * (modelOffset.x * cosR - modelOffset.y * sinR);
                    const mapOffsetY = s * (-modelOffset.x * sinR - modelOffset.y * cosR);
                    newMapPos = { x: manual.mapX + mapOffsetX, y: manual.mapY + mapOffsetY };
                } else {
                    let prevAnchor = null, nextAnchor = null;
                    for (let i = 0; i < manualAnchors.length; i++) {
                        if (manualAnchors[i].originalTrackPointIndex > c.originalTrackPointIndex) {
                            nextAnchor = manualAnchors[i];
                            break;
                        }
                        prevAnchor = manualAnchors[i];
                    }

                    let S1_anchor = prevAnchor, S2_anchor = nextAnchor;
                    if (!S1_anchor) { S1_anchor = manualAnchors[0]; S2_anchor = manualAnchors[1]; }
                    else if (!S2_anchor) { S2_anchor = manualAnchors[manualAnchors.length - 1]; S1_anchor = manualAnchors[manualAnchors.length - 2]; }

                    const S1 = { x: S1_anchor.modelX, y: S1_anchor.modelY }, D1 = { x: S1_anchor.mapX, y: S1_anchor.mapY };
                    const S2 = { x: S2_anchor.modelX, y: S2_anchor.modelY }, D2 = { x: S2_anchor.mapX, y: S2_anchor.mapY };
                    const dSmx = S2.x - S1.x, dSmy = S2.y - S1.y, dDx = D2.x - D1.x, dDy = D2.y - D1.y;
                    const den = dSmx * dSmx + dSmy * dSmy;

                    if (Math.abs(den) < 1e-9) {
                        const totalIndexSpan = S2_anchor.originalTrackPointIndex - S1_anchor.originalTrackPointIndex;
                        const progress = totalIndexSpan > 0 ? (c.originalTrackPointIndex - S1_anchor.originalTrackPointIndex) / totalIndexSpan : 0;
                        newMapPos = { x: D1.x + progress * dDx, y: D1.y + progress * dDy };
                    } else {
                        const sCosR_seg = (dDx * dSmx - dDy * dSmy) / den;
                        const sSinR_seg = (-dDx * dSmy - dDy * dSmx) / den;
                        const Tx_seg = D1.x - (sCosR_seg * S1.x - sSinR_seg * S1.y);
                        const Ty_seg = D1.y - (-sSinR_seg * S1.x - sCosR_seg * S1.y);
                        newMapPos = {
                            x: sCosR_seg * c.modelX - sSinR_seg * c.modelY + Tx_seg,
                            y: -sSinR_seg * c.modelX - sCosR_seg * c.modelY + Ty_seg
                        };
                    }
                }
                if (!anchors.find(a => a.originalTrackPointIndex === trackStartIndex)) {
                    anchors.push({ modelX: c.modelX, modelY: c.modelY, mapX: newMapPos.x, mapY: newMapPos.y,
                        originalTrackPointIndex: c.originalTrackPointIndex, id: 'implicit-track-start' });
                }
            }
            // You would repeat a similar block for the track end point. For brevity, this example omits the end point logic but it would be symmetrical to the start point logic.


            anchors.sort((a, b) => a.originalTrackPointIndex - b.originalTrackPointIndex);
            const uniqueAnchors = anchors.filter((a, i, self) => i === self.findIndex(ua => ua.originalTrackPointIndex === a.originalTrackPointIndex));

            // 3. Generate the warped track line for display.
            const approximateMapFromSingleAnchor = (anchor, modelX, modelY) => {
                const modelOffset = { x: modelX - anchor.modelX, y: modelY - anchor.modelY };
                const s = currentBaseTransform.scale;
                const R = currentBaseTransform.rotation;
                const cosR = Math.cos(R), sinR = Math.sin(R);
                const mapOffsetX = s * (modelOffset.x * cosR - modelOffset.y * sinR);
                const mapOffsetY = s * (-modelOffset.x * sinR - modelOffset.y * cosR);
                return { x: anchor.mapX + mapOffsetX, y: anchor.mapY + mapOffsetY };
            };

            displayTrackScreenPoints = [];
            if (uniqueAnchors.length === 0) { updateButtonStates(); return; }
            if (uniqueAnchors.length === 1) {
                const anchor = uniqueAnchors[0];
                modelTrackPoints.forEach(pt => {
                    const approx = approximateMapFromSingleAnchor(anchor, pt.correctedX, pt.correctedY);
                    displayTrackScreenPoints.push({
                        x: approx.x,
                        y: approx.y,
                        modelIndex: pt.originalIndex,
                        modelX: pt.correctedX,
                        modelY: pt.correctedY
                    });
                });
                updateButtonStates(); return;
            }

            for (let i = 0; i < uniqueAnchors.length - 1; i++) {
                const S1_anchor = uniqueAnchors[i], S2_anchor = uniqueAnchors[i+1];
                const S1 = { x: S1_anchor.modelX, y: S1_anchor.modelY }, D1 = { x: S1_anchor.mapX, y: S1_anchor.mapY };
                const S2 = { x: S2_anchor.modelX, y: S2_anchor.modelY }, D2 = { x: S2_anchor.mapX, y: S2_anchor.mapY };
                const dSmx = S2.x - S1.x, dSmy = S2.y - S1.y, dDx = D2.x - D1.x, dDy = D2.y - D1.y;
                const den = dSmx * dSmx + dSmy * dSmy;

                const segmentModelPoints = modelTrackPoints.filter(p => p.originalIndex >= S1_anchor.originalTrackPointIndex && p.originalIndex <= S2_anchor.originalTrackPointIndex).sort((p1,p2)=>p1.originalIndex-p2.originalIndex);

                if (Math.abs(den) < 1e-9) {
                    segmentModelPoints.forEach(modelPt => {
                        const approx = approximateMapFromSingleAnchor(S1_anchor, modelPt.correctedX, modelPt.correctedY);
                        displayTrackScreenPoints.push({
                            x: approx.x,
                            y: approx.y,
                            modelIndex: modelPt.originalIndex,
                            modelX: modelPt.correctedX,
                            modelY: modelPt.correctedY
                        });
                    });
                } else {
                    const sCosR_seg = (dDx * dSmx - dDy * dSmy) / den;
                    const sSinR_seg = (-dDx * dSmy - dDy * dSmx) / den;
                    const Tx_seg = D1.x - (sCosR_seg * S1.x - sSinR_seg * S1.y);
                    const Ty_seg = D1.y - (-sSinR_seg * S1.x - sCosR_seg * S1.y);
                    segmentModelPoints.forEach(modelPt => {
                        displayTrackScreenPoints.push({
                            x: sCosR_seg * modelPt.correctedX - sSinR_seg * modelPt.correctedY + Tx_seg,
                            y: -sSinR_seg * modelPt.correctedX - sCosR_seg * modelPt.correctedY + Ty_seg,
                            modelIndex: modelPt.originalIndex,
                            modelX: modelPt.correctedX,
                            modelY: modelPt.correctedY
                        });
                    });
                }
            }
            if (displayTrackScreenPoints.length > 1) {
                displayTrackScreenPoints = displayTrackScreenPoints.filter((point, index, self) => {
                    if (index === 0) return true;
                    const prev = self[index - 1];
                    return Math.abs(point.x - prev.x) > 0.1 || Math.abs(point.y - prev.y) > 0.1 || Math.abs(point.modelIndex - prev.modelIndex) > 1e-6;
                });
            }
            recomputeKmMarkers();
            updateButtonStates();
        }

        function recomputeKmMarkers() {
            kmMarkers = [];
            if (!originalTrackPoints.length || displayTrackScreenPoints.length === 0) return;

            const maxMarker = Math.floor(totalTrackLengthKm);
            if (maxMarker < 1) return;

            const indexToPoint = new Map();
            displayTrackScreenPoints.forEach(pt => {
                indexToPoint.set(pt.modelIndex, { x: pt.x, y: pt.y });
            });

            let searchIndex = 0;
            for (let marker = 1; marker <= maxMarker; marker++) {
                while (searchIndex < originalTrackPoints.length && (originalTrackPoints[searchIndex].cumDistKm ?? 0) < marker) {
                    searchIndex++;
                }
                if (searchIndex >= originalTrackPoints.length) break;

                const currentPoint = originalTrackPoints[searchIndex];
                if (Math.abs((currentPoint.cumDistKm ?? 0) - marker) < 1e-6) {
                    const exact = indexToPoint.get(currentPoint.originalIndex);
                    if (exact) {
                        kmMarkers.push({ x: exact.x, y: exact.y, label: marker });
                    }
                    continue;
                }

                const nextPoint = currentPoint;
                const prevIndex = searchIndex - 1;
                if (prevIndex < 0) continue;
                const prevPoint = originalTrackPoints[prevIndex];
                const prevMap = indexToPoint.get(prevPoint.originalIndex);
                const nextMap = indexToPoint.get(nextPoint.originalIndex);
                if (!prevMap || !nextMap) continue;

                const prevCum = prevPoint.cumDistKm ?? 0;
                const nextCum = nextPoint.cumDistKm ?? prevCum;
                const span = nextCum - prevCum;
                if (span <= 0) continue;

                const t = (marker - prevCum) / span;
                const x = prevMap.x + (nextMap.x - prevMap.x) * t;
                const y = prevMap.y + (nextMap.y - prevMap.y) * t;
                kmMarkers.push({ x, y, label: marker });
            }
        }

        function redrawCanvas() {
            if (!canvas.width || !canvas.height) { console.warn("Canvas not sized for redraw"); return; }
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (!mapImage && originalTrackPoints.length === 0) {
                ctx.fillStyle = '#eee'; ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#777'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.font = `16px sans-serif`;
                ctx.fillText('Load map and TCX file', canvas.width / 2, canvas.height / 2);
                return;
            }
            ctx.save();
            ctx.scale(viewTransform.scale, viewTransform.scale);
            ctx.translate(-viewTransform.offsetX, -viewTransform.offsetY);

            if (mapImage) {
                const viewXInMapCoords = viewTransform.offsetX;
                const viewYInMapCoords = viewTransform.offsetY;
                const viewWidthInMapCoords = canvas.width / viewTransform.scale;
                const viewHeightInMapCoords = canvas.height / viewTransform.scale;
                const sx = Math.max(0, viewXInMapCoords);
                const sy = Math.max(0, viewYInMapCoords);
                const sEndX = Math.min(mapImage.width, viewXInMapCoords + viewWidthInMapCoords);
                const sEndY = Math.min(mapImage.height, viewYInMapCoords + viewHeightInMapCoords);
                const sWidth = sEndX - sx;
                const sHeight = sEndY - sy;
                if (sWidth > 0 && sHeight > 0) {
                    const dx = sx; const dy = sy; const dWidth = sWidth; const dHeight = sHeight;
                    ctx.drawImage(mapImage, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight );
                }
            } else {
                ctx.fillStyle = '#ddd';
                ctx.fillRect(viewTransform.offsetX, viewTransform.offsetY, canvas.width / viewTransform.scale, canvas.height / viewTransform.scale);
                const fontSize = 20 / viewTransform.scale; ctx.font = `${fontSize}px sans-serif`;
                ctx.fillStyle = '#777'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText('Load map', viewTransform.offsetX + (canvas.width / viewTransform.scale) / 2, viewTransform.offsetY + (canvas.height / viewTransform.scale) / 2);
            }

            if (displayTrackScreenPoints.length > 1) {
                ctx.beginPath(); ctx.strokeStyle = appearance.trackColor;
                const trackWidth = (showWideTrack ? appearance.trackWidth * 6 : appearance.trackWidth) / viewTransform.scale;
                ctx.lineWidth = trackWidth;
                const prevAlpha = ctx.globalAlpha;
                ctx.globalAlpha = showWideTrack ? 0.4 : prevAlpha;
                ctx.moveTo(displayTrackScreenPoints[0].x, displayTrackScreenPoints[0].y);
                for (let i = 1; i < displayTrackScreenPoints.length; i++) {
                    ctx.lineTo(displayTrackScreenPoints[i].x, displayTrackScreenPoints[i].y);
                }
                ctx.stroke();
                ctx.globalAlpha = prevAlpha;
            }
            if (showKmMarks && kmMarkers.length > 0) {
                const markerRadius = 12 / viewTransform.scale;
                const strokeWidth = 2 / viewTransform.scale;
                const fontSize = 12 / viewTransform.scale;
                ctx.save();
                ctx.font = `${fontSize}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                kmMarkers.forEach(marker => {
                    ctx.beginPath();
                    ctx.fillStyle = 'rgba(255,255,255,0.85)';
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = strokeWidth;
                    ctx.arc(marker.x, marker.y, markerRadius, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                    ctx.fillStyle = '#000';
                    ctx.fillText(marker.label.toString(), marker.x, marker.y);
                });
                ctx.restore();
            }
            controls.forEach(c => {
                ctx.beginPath();
                let fillColor = appearance.controlColorInitial;
                if (c.isCustom) {
                    fillColor = appearance.controlColorCustom;
                } else if (c.isUserManuallyPositioned) {
                    fillColor = appearance.controlColor;
                } else if (activeGlobalTransform) {
                    fillColor = appearance.controlColorGlobal;
                }

                if (selectedControlForPlacementId === c.id && (currentMode.startsWith('placingOnMap') || currentMode.startsWith('selectingControl'))) fillColor = 'orange';
                else if (activeDragControlId === c.id) fillColor = 'rgba(255,165,0,0.8)';
                ctx.arc(c.mapX, c.mapY, appearance.controlRadius / viewTransform.scale, 0, 2 * Math.PI);
                ctx.strokeStyle = fillColor;
                ctx.lineWidth = (appearance.trackWidth / viewTransform.scale);
                ctx.stroke();

                if (c.isGlobalAnchor && globalAnchorPairs.find(p=>p.controlId === c.id)) {
                    ctx.strokeStyle = 'lime';
                    ctx.lineWidth = (appearance.trackWidth / viewTransform.scale);
                    ctx.stroke();
                }
            });
            ctx.restore();
        }

        function startGlobalAlignment() {
            if (!mapImage || originalTrackPoints.length === 0) return;
            globalAnchorPairs = [];
            controls.forEach(c => { c.isGlobalAnchor = false; });
            currentMode = 'selectingControlForGlobal1';
            updateStatus("<b>Step 1/4:</b> Click 1st control on track.");
            updateButtonStates(); updateGlobalAnchorListUI(); redrawCanvas();
        }
        function resetAlignment() {
            if (!mapImage || originalTrackPoints.length === 0) { updateStatus("Load files first."); return; }
            processLoadedDataAndSetInitialDisplay();
            activeGlobalTransform = null;
            globalAnchorPairs = [];
            updateGlobalAnchorListUI();
            currentMode = 'idle';
            updateStatus("Alignment reset to initial state.");
            updateButtonStates();
            if (mapImage) zoomToFitMap(); else redrawCanvas();
        }
        function updateGlobalAnchorListUI() {
            if (!globalAnchorListEl) return;
            globalAnchorListEl.innerHTML = '';
            globalAnchorPairs.forEach((pair, index) => {
                const control = controls.find(c => c.id === pair.controlId);
                const li = document.createElement('li');
                let displayName = control ? control.id : '??';
                if (control && control.id.includes('-')) {
                    displayName = control.id.substring(control.id.lastIndexOf('-') + 1);
                }
                li.textContent = `Pair ${index+1}: Ctrl ${displayName} at Map (${pair.mapX.toFixed(0)}, ${pair.mapY.toFixed(0)})`;
                globalAnchorListEl.appendChild(li);
            });
        }

        function saveImage() {
            if (!mapImage) {
                console.warn('Cannot save: map image not loaded.');
                return;
            }
            saveZipWithVariants();
        }

        function saveZipWithVariants() {
            const images = [];

            const renderVariant = (drawControls, suffix) => {
                const canvasVar = document.createElement('canvas');
                canvasVar.width = mapImage.width;
                canvasVar.height = mapImage.height;
                const ctxVar = canvasVar.getContext('2d');
                ctxVar.drawImage(mapImage, 0, 0, mapImage.width, mapImage.height);

                if (displayTrackScreenPoints.length > 1) {
                    ctxVar.beginPath();
                    ctxVar.strokeStyle = appearance.trackColor;
                    const exportTrackWidth = showWideTrack ? appearance.trackWidth * 6 : appearance.trackWidth;
                    ctxVar.lineWidth = exportTrackWidth;
                    const prevAlphaVar = ctxVar.globalAlpha;
                    ctxVar.globalAlpha = showWideTrack ? 0.4 : prevAlphaVar;
                    ctxVar.moveTo(displayTrackScreenPoints[0].x, displayTrackScreenPoints[0].y);
                    for (let i = 1; i < displayTrackScreenPoints.length; i++) {
                        ctxVar.lineTo(displayTrackScreenPoints[i].x, displayTrackScreenPoints[i].y);
                    }
                    ctxVar.stroke();
                    ctxVar.globalAlpha = prevAlphaVar;
                }
                if (showKmMarks && kmMarkers.length > 0) {
                    const markerRadius = 12;
                    const strokeWidth = 2;
                    const fontSize = 16;
                    ctxVar.save();
                    ctxVar.font = `${fontSize}px sans-serif`;
                    ctxVar.textAlign = 'center';
                    ctxVar.textBaseline = 'middle';
                    kmMarkers.forEach(marker => {
                        ctxVar.beginPath();
                        ctxVar.fillStyle = 'rgba(255,255,255,0.85)';
                        ctxVar.strokeStyle = '#000';
                        ctxVar.lineWidth = strokeWidth;
                        ctxVar.arc(marker.x, marker.y, markerRadius, 0, 2 * Math.PI);
                        ctxVar.fill();
                        ctxVar.stroke();
                        ctxVar.fillStyle = '#000';
                        ctxVar.fillText(marker.label.toString(), marker.x, marker.y);
                    });
                    ctxVar.restore();
                }

                if (drawControls) {
                    controls.forEach(c => {
                        ctxVar.beginPath();
                        let strokeColor = appearance.controlColorInitial;
                        if (c.isCustom) {
                            strokeColor = appearance.controlColorCustom;
                        } else if (c.isUserManuallyPositioned) {
                            strokeColor = appearance.controlColor;
                        } else if (activeGlobalTransform) {
                            strokeColor = appearance.controlColorGlobal;
                        }
                        ctxVar.arc(c.mapX, c.mapY, appearance.controlRadius, 0, 2 * Math.PI);
                        ctxVar.strokeStyle = strokeColor;
                        ctxVar.lineWidth = appearance.trackWidth;
                        ctxVar.stroke();

                        if (c.isGlobalAnchor && globalAnchorPairs.find(p => p.controlId === c.id)) {
                            ctxVar.beginPath();
                            ctxVar.arc(c.mapX, c.mapY, appearance.controlRadius, 0, 2 * Math.PI);
                            ctxVar.strokeStyle = 'lime';
                            ctxVar.lineWidth = appearance.trackWidth;
                            ctxVar.stroke();
                        }
                    });
                }

                const dataUrl = canvasVar.toDataURL('image/png');
                const binary = atob(dataUrl.split(',')[1]);
                const bytes = new Uint8Array(binary.length);
                for (let i = 0; i < binary.length; i++) {
                    bytes[i] = binary.charCodeAt(i);
                }
                const base = (originalMapFileName || 'map').replace(/\.[^.]+$/, '');
                images.push({ name: `${base}_${suffix}.png`, bytes });
            };

            renderVariant(false, 't');
            renderVariant(true, 'tc');

            const zipBlob = buildZip(images);
            const baseName = (originalMapFileName || 'map').replace(/\.[^.]+$/, '');
            const link = document.createElement('a');
            link.href = URL.createObjectURL(zipBlob);
            link.download = `${baseName}.zip`;
            document.body.appendChild(link);
            link.click();
            setTimeout(() => {
                URL.revokeObjectURL(link.href);
                document.body.removeChild(link);
            }, 1500);
        }

        function buildZip(files) {
            const encoder = new TextEncoder();
            let offset = 0;
            const localChunks = [];
            const centralChunks = [];

            files.forEach(file => {
                const nameBytes = encoder.encode(file.name);
                const data = file.bytes;
                const crc = crc32(data);

                const localHeader = new Uint8Array(30 + nameBytes.length);
                const lh = new DataView(localHeader.buffer);
                lh.setUint32(0, 0x04034b50, true);
                lh.setUint16(4, 20, true);
                lh.setUint16(6, 0, true);
                lh.setUint16(8, 0, true);
                lh.setUint16(10, 0, true);
                lh.setUint16(12, 0, true);
                lh.setUint32(14, crc, true);
                lh.setUint32(18, data.length, true);
                lh.setUint32(22, data.length, true);
                lh.setUint16(26, nameBytes.length, true);
                lh.setUint16(28, 0, true);
                localHeader.set(nameBytes, 30);

                localChunks.push(localHeader, data);

                const centralHeader = new Uint8Array(46 + nameBytes.length);
                const ch = new DataView(centralHeader.buffer);
                ch.setUint32(0, 0x02014b50, true);
                ch.setUint16(4, 20, true);
                ch.setUint16(6, 20, true);
                ch.setUint16(8, 0, true);
                ch.setUint16(10, 0, true);
                ch.setUint16(12, 0, true);
                ch.setUint16(14, 0, true);
                ch.setUint32(16, crc, true);
                ch.setUint32(20, data.length, true);
                ch.setUint32(24, data.length, true);
                ch.setUint16(28, nameBytes.length, true);
                ch.setUint16(30, 0, true);
                ch.setUint16(32, 0, true);
                ch.setUint16(34, 0, true);
                ch.setUint16(36, 0, true);
                ch.setUint32(38, 0, true);
                ch.setUint32(42, offset, true);
                centralHeader.set(nameBytes, 46);

                centralChunks.push(centralHeader);
                offset += localHeader.length + data.length;
            });

            let centralSize = 0;
            centralChunks.forEach(chunk => { centralSize += chunk.length; });

            const end = new Uint8Array(22);
            const endView = new DataView(end.buffer);
            endView.setUint32(0, 0x06054b50, true);
            endView.setUint16(4, 0, true);
            endView.setUint16(6, 0, true);
            endView.setUint16(8, files.length, true);
            endView.setUint16(10, files.length, true);
            endView.setUint32(12, centralSize, true);
            endView.setUint32(16, offset, true);
            endView.setUint16(20, 0, true);

            const totalSize = offset + centralSize + end.length;
            const zipBuffer = new Uint8Array(totalSize);
            let cursor = 0;
            localChunks.forEach(chunk => {
                zipBuffer.set(chunk, cursor);
                cursor += chunk.length;
            });
            centralChunks.forEach(chunk => {
                zipBuffer.set(chunk, cursor);
                cursor += chunk.length;
            });
            zipBuffer.set(end, cursor);
            return new Blob([zipBuffer], { type: 'application/zip' });
        }

        function crc32(data) {
            let crc = 0 ^ (-1);
            for (let i = 0; i < data.length; i++) {
                crc = (crc >>> 8) ^ crcTable[(crc ^ data[i]) & 0xff];
            }
            return (crc ^ (-1)) >>> 0;
        }

        const crcTable = (() => {
            const table = new Uint32Array(256);
            for (let n = 0; n < 256; n++) {
                let c = n;
                for (let k = 0; k < 8; k++) {
                    c = (c & 1) ? (0xedb88320 ^ (c >>> 1)) : (c >>> 1);
                }
                table[n] = c >>> 0;
            }
            return table;
        })();

        init();
    </script>
</body>
</html>
